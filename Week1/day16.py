# coding=utf-8
# __author:"NGLS Chuang"
# date: 2019/12/04
"""
FTP联系 ，大量用到了 OS 模块。
要求：
用户加密认真             #token
准许同时多用户登录        #多线程，or 多进程
每个用户有自己的家目录，且每个用户只能访问自己家目录
对用户进行磁盘配额，每个用户的可用空间不同。
准许用户子FTP server上随意切换目录
准许用户查看当前目录下的文件，
准许上传下载文件，
文件传输过程中显示进度条
支持文件断点续传
p216-p218 讲解 貌似是在liux 系统上的交互程序。
"""
"""
选课系统
角色:学校、学员、课程、讲师

要求:

创建北京、上海 2 所学校

创建linux , python , go 3个课程 ， linux\py 在北京开， go 在上海开

课程包含，周期，价格，通过学校创建课程

通过学校创建班级， 班级关联课程、讲师

创建学员时，选择学校，关联班级

创建讲师角色时要关联学校，

提供两个角色接口

学员视图， 可以注册， 交学费， 选择班级， 讲师视图， 讲师可管理自己的班级，
 上课时选择班级， 查看班级学员列表 ， 
 修改所管理的学员的成绩 管理视图，创建讲师， 
 创建班级，创建课程 上面的操作产生的数据都通过pickle序列化保存到文件里
"""
"""
面向对象 究极升级
1.依赖关系，我可以随时用你，但你不属于我。
举例：大象把自己关进冰箱。
    冰箱的功能非常简单, 只要会开门关门就行了. 但是大象就没那么简单了,想想,
    大象开门和关门的时候是不是要先找个冰箱啊, 然后呢? 
    打开冰箱门,是不是打开刚才找到的那个冰箱门, 然后装自己,最后呢? 关冰箱门, 
    注意, 关的是刚才那个冰箱吧. 也就是说, 开门和关门用的是一个冰箱,并且大象有更换冰箱的权利,
    想进哪个冰箱就进哪个冰箱. 这时, 大象类和冰箱类的关系并没有那么的紧密,
    因为大象可以指定任何一个冰箱. 接下来,演示一下. 

class Elphant:
    def __init__(self, name):    注意！这里没有接收对象。所以不属于。
        self.name = name
    def open(self, ref):
        print("大象要开门了. 默念三声. 开!")
        # 由外界传递进来一个冰箱, 让冰箱开门, 这时大象不用背着冰箱到处跑.
        # 类与类之间的关系也就不那么的紧密了, 换句话说, 只要是有open_door()方法的对象.  都可以接收运行
        ref.open_door()
  
    def close(self, ref):
        print("大象要关门了. 默念三声. 关!")
        ref.close_door()            
        pass
    def take(self):
        print("钻进去")
 
class Refrigerator:
    def open_door(self):
        print("冰箱门被打开了")
    def close_door(self):
        print("冰箱门被关上了")
# 造冰箱
r = Refrigerator()
# 造大象
el = Elphant("神奇的大象")
el.open(r) # 注意,此时是把一个冰箱作为参数传递进去了,也就是说,大象可以指定任何一个冰箱.
el.take()
el.close(r)
　　说白了 就时把一个类当对象传过去（类的方法中的参数接受），传过去后，在内部调用这个类的方法，岂不美哉
    这种关系，就是兼职关系，用你你就来，不用就给我滚。 
    
2.关联关系.组合关系.聚合关系
  其实这三个在代码上写法是一样的. 但是, 从含义上是不一样的. 
  2.1 关联关系: 两种事物必须是互相关联的,但是在某些特殊情况下是可以更改和更换的
    举例子 你和女朋友，/学校和老师。需要她，她也是你的。
    class Boy:
    def __init__(self, name, girlFriend=None):#这里将对象传到了构造函数里。
        self.name = name
        self.girlFriend = girlFriend
 
    def have_a_dinner(self):
        if self.girlFriend:
            print("%s 和 %s⼀起去吃晚餐" % (self.name, self.girlFriend.name))
        else:
            print("单身狗. 吃什么饭")
 
    class Girl:
        def __init__(self, name):
            self.name = name
     
    b = Boy("alex")
    b.have_a_dinner()
     
    # 突然牛B了. 找到女朋友了
    g = Girl("如花")
    b.girlFriend = g # 有女朋友了. 6666
    b.have_a_dinner()
     
    gg = Girl("李小花")
    bb = Boy("wusir", gg) # 娃娃亲. 出生就有女朋友. 服不服
     
    bb.have_a_dinner() # 多么幸福的一家
     
    # 突然.bb失恋了. 娃娃亲不跟他好了
    bb.girlFriend = None
     
    bb.have_a_dinner() # 又单身了         没有这个对象 则不能 进行吃饭方法。
    
　2.2 聚合关系: 属于关联关系中的一种特例,侧重点是xxx和xxx聚合成xxx. 各自有各自的生命周期, 比如电脑,电脑里有CPU,
 硬盘, 内存等等,电脑挂了, CPU还是好的,还是完整的个体
       比如一个学校 可以有一堆老师。 老师只能属于一个学校。但双方相互离开都还是个体。
　2.3 组合关系: 属于关联关系中的一种特例, 写法上差不多,组合关系比聚合还要紧密,比如人的大脑, 心脏, 各个器官. 
这些器官组合成一个人. 这时人如果挂了,其他的东西也跟着挂了. 
"""